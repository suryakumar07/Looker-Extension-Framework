{"version":3,"file":"useBlur.js","names":["useContext","ComboboxActionType","ComboboxState","useBlur","context","data","inputValue","state","transition","listRef","inputElement","freeInputPropRef","closeList","action","payload","current","undefined","handleBlur","e","IDLE","ESCAPE","nextFocusTarget","relatedTarget","popoverCurrent","focusInList","contains","INTERACTING","INTERACT","BLUR","preventDefault"],"sources":["../../../../../../src/Form/Inputs/Combobox/utils/useBlur.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\n// Much of the following is pulled from https://github.com/reach/reach-ui\n// because their work is fantastic (but is not in TypeScript)\nimport type { Context, FocusEvent } from 'react'\nimport { useContext } from 'react'\nimport type {\n  ComboboxContextProps,\n  ComboboxMultiContextProps,\n} from '../ComboboxContext'\nimport { ComboboxActionType, ComboboxState } from './state'\n\nexport function useBlur<\n  TContext extends\n    | ComboboxContextProps\n    | ComboboxMultiContextProps = ComboboxContextProps\n>(context: Context<TContext>) {\n  const {\n    data: { inputValue },\n    state,\n    transition,\n    listRef,\n    inputElement,\n    freeInputPropRef,\n  } = useContext(context)\n\n  function closeList(action: ComboboxActionType) {\n    // When freeInput is true, the current inputValue should not be changed on blur\n    // (for Multi, InputChips will tokenize the inputValue on blur)\n    const payload =\n      freeInputPropRef && freeInputPropRef.current ? { inputValue } : undefined\n\n    transition && transition(action, payload)\n  }\n\n  return function handleBlur(e?: FocusEvent) {\n    if (!e) {\n      // handleBlur was called directly (via popover close)\n      // only need to close the list\n      if (state !== ComboboxState.IDLE) {\n        closeList(ComboboxActionType.ESCAPE)\n      }\n      return\n    }\n    // we on want to close only if focus rests outside the select\n    const nextFocusTarget = e.relatedTarget\n    const popoverCurrent = listRef ? listRef.current : null\n    if (popoverCurrent) {\n      const focusInList =\n        popoverCurrent && popoverCurrent.contains(nextFocusTarget)\n\n      if (focusInList && state !== ComboboxState.INTERACTING) {\n        // focus landed inside the select, keep it open\n        transition && transition(ComboboxActionType.INTERACT)\n      } else if (!focusInList && nextFocusTarget !== inputElement) {\n        // focus landed outside the select, close it\n        closeList(ComboboxActionType.BLUR)\n      }\n      // Stop ComboboxMultiInput + freeInput underlying InputChips blur handler from\n      // tokenizing input value when an option is clicked\n      focusInList &&\n        freeInputPropRef &&\n        freeInputPropRef.current &&\n        e.preventDefault()\n    }\n  }\n}\n"],"mappings":";;AAQA,SAASA,UAAU,QAAQ,OAAO;AAKlC,SAASC,kBAAkB,EAAEC,aAAa,QAAQ,SAAS;AAE3D,OAAO,SAASC,OAAO,CAIrBC,OAA0B,EAAE;EAC5B,MAAM;IACJC,IAAI,EAAE;MAAEC;IAAW,CAAC;IACpBC,KAAK;IACLC,UAAU;IACVC,OAAO;IACPC,YAAY;IACZC;EACF,CAAC,GAAGX,UAAU,CAACI,OAAO,CAAC;EAEvB,SAASQ,SAAS,CAACC,MAA0B,EAAE;IAG7C,MAAMC,OAAO,GACXH,gBAAgB,IAAIA,gBAAgB,CAACI,OAAO,GAAG;MAAET;IAAW,CAAC,GAAGU,SAAS;IAE3ER,UAAU,IAAIA,UAAU,CAACK,MAAM,EAAEC,OAAO,CAAC;EAC3C;EAEA,OAAO,SAASG,UAAU,CAACC,CAAc,EAAE;IACzC,IAAI,CAACA,CAAC,EAAE;MAGN,IAAIX,KAAK,KAAKL,aAAa,CAACiB,IAAI,EAAE;QAChCP,SAAS,CAACX,kBAAkB,CAACmB,MAAM,CAAC;MACtC;MACA;IACF;IAEA,MAAMC,eAAe,GAAGH,CAAC,CAACI,aAAa;IACvC,MAAMC,cAAc,GAAGd,OAAO,GAAGA,OAAO,CAACM,OAAO,GAAG,IAAI;IACvD,IAAIQ,cAAc,EAAE;MAClB,MAAMC,WAAW,GACfD,cAAc,IAAIA,cAAc,CAACE,QAAQ,CAACJ,eAAe,CAAC;MAE5D,IAAIG,WAAW,IAAIjB,KAAK,KAAKL,aAAa,CAACwB,WAAW,EAAE;QAEtDlB,UAAU,IAAIA,UAAU,CAACP,kBAAkB,CAAC0B,QAAQ,CAAC;MACvD,CAAC,MAAM,IAAI,CAACH,WAAW,IAAIH,eAAe,KAAKX,YAAY,EAAE;QAE3DE,SAAS,CAACX,kBAAkB,CAAC2B,IAAI,CAAC;MACpC;MAGAJ,WAAW,IACTb,gBAAgB,IAChBA,gBAAgB,CAACI,OAAO,IACxBG,CAAC,CAACW,cAAc,EAAE;IACtB;EACF,CAAC;AACH"}