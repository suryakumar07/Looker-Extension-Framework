{"version":3,"file":"useComboboxRefs.js","names":["useRef","useCallbackRef","useComboboxRefs","forwardedRef","wrapperElement","ref","optionsRef","listRef","autoCompletePropRef","inputReadOnlyPropRef","persistSelectionPropRef","closeOnSelectPropRef","windowingPropRef","isScrollingRef","indicatorPropRef","freeInputPropRef"],"sources":["../../../../../../src/Form/Inputs/Combobox/utils/useComboboxRefs.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\nimport type { Ref } from 'react'\nimport { useRef } from 'react'\nimport { useCallbackRef } from '../../../../utils'\nimport type { ComboboxOptionObject } from '../types'\n\nexport function useComboboxRefs(forwardedRef: Ref<HTMLDivElement>) {\n  // Need this to get the menu width\n  const [wrapperElement, ref] = useCallbackRef<HTMLDivElement>(forwardedRef)\n  // We store the values of all the ComboboxOptions on this ref. This makes it\n  // possible to perform the keyboard navigation from the input on the list. We\n  // manipulate this array through context so that we don't have to enforce a\n  // parent/child relationship between ComboboxList and ComboboxOption with\n  // cloneElement or fall back to DOM traversal. It's a new trick for me and\n  // I'm pretty excited about it.\n  const optionsRef = useRef<ComboboxOptionObject[]>([])\n\n  const listRef = useRef<HTMLElement | null>(null)\n\n  // When <ComboboxInput autoComplete={false} /> we don't want cycle back to\n  // the user's value while navigating (because it's always the user's value),\n  // but we need to know this in useKeyDown which is far away from the prop\n  // here, so we do something sneaky and write it to this ref on context so we\n  // can use it anywhere else ðŸ˜›. Another new trick for me and I'm excited\n  // about this one too!\n  const autoCompletePropRef = useRef(true)\n  const inputReadOnlyPropRef = useRef(false)\n\n  const persistSelectionPropRef = useRef(false)\n  const closeOnSelectPropRef = useRef(true)\n  const windowingPropRef = useRef(false)\n  const isScrollingRef = useRef(false)\n  const indicatorPropRef = useRef(false)\n  const freeInputPropRef = useRef(false)\n\n  return {\n    autoCompletePropRef,\n    closeOnSelectPropRef,\n    freeInputPropRef,\n    indicatorPropRef,\n    inputReadOnlyPropRef,\n    isScrollingRef,\n    listRef,\n    optionsRef,\n    persistSelectionPropRef,\n    ref,\n    windowingPropRef,\n    wrapperElement,\n  }\n}\n"],"mappings":";;AAMA,SAASA,MAAM,QAAQ,OAAO;AAC9B,SAASC,cAAc,QAAQ,mBAAmB;AAGlD,OAAO,SAASC,eAAe,CAACC,YAAiC,EAAE;EAEjE,MAAM,CAACC,cAAc,EAAEC,GAAG,CAAC,GAAGJ,cAAc,CAAiBE,YAAY,CAAC;EAO1E,MAAMG,UAAU,GAAGN,MAAM,CAAyB,EAAE,CAAC;EAErD,MAAMO,OAAO,GAAGP,MAAM,CAAqB,IAAI,CAAC;;EAQhD,MAAMQ,mBAAmB,GAAGR,MAAM,CAAC,IAAI,CAAC;EACxC,MAAMS,oBAAoB,GAAGT,MAAM,CAAC,KAAK,CAAC;EAE1C,MAAMU,uBAAuB,GAAGV,MAAM,CAAC,KAAK,CAAC;EAC7C,MAAMW,oBAAoB,GAAGX,MAAM,CAAC,IAAI,CAAC;EACzC,MAAMY,gBAAgB,GAAGZ,MAAM,CAAC,KAAK,CAAC;EACtC,MAAMa,cAAc,GAAGb,MAAM,CAAC,KAAK,CAAC;EACpC,MAAMc,gBAAgB,GAAGd,MAAM,CAAC,KAAK,CAAC;EACtC,MAAMe,gBAAgB,GAAGf,MAAM,CAAC,KAAK,CAAC;EAEtC,OAAO;IACLQ,mBAAmB;IACnBG,oBAAoB;IACpBI,gBAAgB;IAChBD,gBAAgB;IAChBL,oBAAoB;IACpBI,cAAc;IACdN,OAAO;IACPD,UAAU;IACVI,uBAAuB;IACvBL,GAAG;IACHO,gBAAgB;IAChBR;EACF,CAAC;AACH"}