{"version":3,"file":"useBlur.js","names":["useBlur","context","useContext","inputValue","data","state","transition","listRef","inputElement","freeInputPropRef","closeList","action","payload","current","undefined","handleBlur","e","ComboboxState","IDLE","ComboboxActionType","ESCAPE","nextFocusTarget","relatedTarget","popoverCurrent","focusInList","contains","INTERACTING","INTERACT","BLUR","preventDefault"],"sources":["../../../../../../src/Form/Inputs/Combobox/utils/useBlur.ts"],"sourcesContent":["/**\n * Copyright (c) 2023 Google LLC\n * SPDX-License-Identifier: MIT\n */\n\n// Much of the following is pulled from https://github.com/reach/reach-ui\n// because their work is fantastic (but is not in TypeScript)\nimport type { Context, FocusEvent } from 'react'\nimport { useContext } from 'react'\nimport type {\n  ComboboxContextProps,\n  ComboboxMultiContextProps,\n} from '../ComboboxContext'\nimport { ComboboxActionType, ComboboxState } from './state'\n\nexport function useBlur<\n  TContext extends\n    | ComboboxContextProps\n    | ComboboxMultiContextProps = ComboboxContextProps\n>(context: Context<TContext>) {\n  const {\n    data: { inputValue },\n    state,\n    transition,\n    listRef,\n    inputElement,\n    freeInputPropRef,\n  } = useContext(context)\n\n  function closeList(action: ComboboxActionType) {\n    // When freeInput is true, the current inputValue should not be changed on blur\n    // (for Multi, InputChips will tokenize the inputValue on blur)\n    const payload =\n      freeInputPropRef && freeInputPropRef.current ? { inputValue } : undefined\n\n    transition && transition(action, payload)\n  }\n\n  return function handleBlur(e?: FocusEvent) {\n    if (!e) {\n      // handleBlur was called directly (via popover close)\n      // only need to close the list\n      if (state !== ComboboxState.IDLE) {\n        closeList(ComboboxActionType.ESCAPE)\n      }\n      return\n    }\n    // we on want to close only if focus rests outside the select\n    const nextFocusTarget = e.relatedTarget\n    const popoverCurrent = listRef ? listRef.current : null\n    if (popoverCurrent) {\n      const focusInList =\n        popoverCurrent && popoverCurrent.contains(nextFocusTarget)\n\n      if (focusInList && state !== ComboboxState.INTERACTING) {\n        // focus landed inside the select, keep it open\n        transition && transition(ComboboxActionType.INTERACT)\n      } else if (!focusInList && nextFocusTarget !== inputElement) {\n        // focus landed outside the select, close it\n        closeList(ComboboxActionType.BLUR)\n      }\n      // Stop ComboboxMultiInput + freeInput underlying InputChips blur handler from\n      // tokenizing input value when an option is clicked\n      focusInList &&\n        freeInputPropRef &&\n        freeInputPropRef.current &&\n        e.preventDefault()\n    }\n  }\n}\n"],"mappings":";;;;;;AAQA;AAKA;;AAEO,SAASA,OAAO,CAIrBC,OAA0B,EAAE;EAC5B,kBAOI,IAAAC,iBAAU,EAACD,OAAO,CAAC;IANbE,UAAU,eAAlBC,IAAI,CAAID,UAAU;IAClBE,KAAK,eAALA,KAAK;IACLC,UAAU,eAAVA,UAAU;IACVC,OAAO,eAAPA,OAAO;IACPC,YAAY,eAAZA,YAAY;IACZC,gBAAgB,eAAhBA,gBAAgB;EAGlB,SAASC,SAAS,CAACC,MAA0B,EAAE;IAG7C,IAAMC,OAAO,GACXH,gBAAgB,IAAIA,gBAAgB,CAACI,OAAO,GAAG;MAAEV,UAAU,EAAVA;IAAW,CAAC,GAAGW,SAAS;IAE3ER,UAAU,IAAIA,UAAU,CAACK,MAAM,EAAEC,OAAO,CAAC;EAC3C;EAEA,OAAO,SAASG,UAAU,CAACC,CAAc,EAAE;IACzC,IAAI,CAACA,CAAC,EAAE;MAGN,IAAIX,KAAK,KAAKY,oBAAa,CAACC,IAAI,EAAE;QAChCR,SAAS,CAACS,yBAAkB,CAACC,MAAM,CAAC;MACtC;MACA;IACF;IAEA,IAAMC,eAAe,GAAGL,CAAC,CAACM,aAAa;IACvC,IAAMC,cAAc,GAAGhB,OAAO,GAAGA,OAAO,CAACM,OAAO,GAAG,IAAI;IACvD,IAAIU,cAAc,EAAE;MAClB,IAAMC,WAAW,GACfD,cAAc,IAAIA,cAAc,CAACE,QAAQ,CAACJ,eAAe,CAAC;MAE5D,IAAIG,WAAW,IAAInB,KAAK,KAAKY,oBAAa,CAACS,WAAW,EAAE;QAEtDpB,UAAU,IAAIA,UAAU,CAACa,yBAAkB,CAACQ,QAAQ,CAAC;MACvD,CAAC,MAAM,IAAI,CAACH,WAAW,IAAIH,eAAe,KAAKb,YAAY,EAAE;QAE3DE,SAAS,CAACS,yBAAkB,CAACS,IAAI,CAAC;MACpC;MAGAJ,WAAW,IACTf,gBAAgB,IAChBA,gBAAgB,CAACI,OAAO,IACxBG,CAAC,CAACa,cAAc,EAAE;IACtB;EACF,CAAC;AACH"}